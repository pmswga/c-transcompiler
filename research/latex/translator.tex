\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[14pt]{extsizes}
\usepackage{graphicx}
\usepackage{url} 
\textwidth=16cm
\begin{document}
	\setcounter{tocdepth}{2}

	\include{title}

	\newpage

	\begin{center}
	\tableofcontents
	\end{center}


	\newpage

	\newcounter{example}[section]


	\section{Аннотация}

	Миграция кода является актуальной задачей в работе с унаследованной кодовой базой. Необходимость миграции с одной версии языка на актуальную позволяет избежать уязвимостей старых версий, избежать ошибок (исправленных в новых версиях языка), повысить быстродействие и эффективность работы кода. Однако, данная задача является сложной и до сих пор наблюдается дефицит соответствующих инструментальных средств, позволяющих мигрировать с одного языка на другой в автоматическом режиме или хотя бы позволяющих облегчить этот процесс.
	
	Статья посвящена миграции кода с языка С89/С99 на C11/C17.

	\textit{\textbf{Ключевые слова:} портирование программного обеспечения, переносимость программ, миграция кода}

	\section{Миграция}

	Миграция (англ. Migration) -- процесс перехода от одних инструментальных средств к другим. Например от одного языка программирования на другой. Сам процесс миграция встречается в базах данных, прикладных и веб-приложениях, при переходе с одной версии языка на другую. С миграцей связаны следующие проблемы \refstepcounter{example}[\theexample]:

	\begin{enumerate}
		\item{Неорганизованность -- перед началом миграции необходимо составить соответствующий план}
		\item{Потеря данных -- при переносе данных из одного места в другое, они могут потеряться. Поэтому необходимо использовать резервные}
		\item{Вопросы совместимости -- при переходе на новую версию инструментального средства (язык, библиотека, фреймворк и т.д.) может вызывать проблемы с обратной совместимостью, так как в новых версиях может отсутствовать ранее присутствующая функциональность }
		\item{Проблемы с оборудованием -- при переходе на новую аппаратную или программную среду (операционную систему) необходимо учитывать их возможности и совместимость}
	\end{enumerate}

	\section{Миграция кода}

	Миграция кода -- процесс непосредственного перехода от одной версии языка на другую версию языка. Например, с C++11 на C++17.

	Основной причиной миграций код является выпуск новых версий языка, фреймворков, библиотек или даже появление более совершенных инструментальных средств. Не менее важным является процесс миграции кода, который должен быть переодическим, как его тестирование и отладка. Вот несколько причин, по которым это необходимо:

	\begin{itemize}
		\item{Исправление ошибок в новых версиях языка}
		\item{Уточнение поведения языка}
		\item{Добавление новых возможностей}
		\item{Повышение производительности за счёт улучшения работы компилятора}
		\item{Повышение надёжности и безопасности кода}
		\item{Исправление ошибок в работе компилятора}
		\item{Избавление от устаревших возможностей}
	\end{itemize}
	
	Примеры миграций приведены в источниках \refstepcounter{example}[\theexample]\refstepcounter{example}[\theexample]\refstepcounter{example}[\theexample]\refstepcounter{example}[\theexample], которые подтверждают актуальность данного вопроса.

	\subsection{Способы и инструментальные средства}

	Способы миграции условно можно разделить на: 

	\begin{itemize}
		\item{Ручной -- разработчики самостоятельно изменяют или переписывают код}
		\item{Автоматический -- использование инструментальных средств позволяющие облегчающих миграцию}
	\end{itemize}

	Ручной способ менее предпочтителен, так как может повлечь за собой появление ошибок, искажение работы исходных алгоритмов. Помимо этого данный способ требует очень много времени на осуществление миграции.

	Автоматический же способ наиболее предпочтителен, так как сокращает участие человека в процессе миграции и даже может оптимизировать получающийся код, в свою очередь это сократит количество потенциальных ошибок. Однако, сложность состоит в том, что практически нет средств, осуществляющие полноценную миграцию без участия разработчика. Сложность, в разработке таких средств, состоит в том, что не смотря на строгую формальную систему языка необходимо учитывать и понимать семантику.

	Примеры инструментальных средств:
	
	\begin{enumerate}
		\item{Porting Assistant for .NET\refstepcounter{example}[\theexample]}
		\item{Port Assist\refstepcounter{example}[\theexample]}
		\item{CodeCheck\refstepcounter{example}[\theexample]}
		\item{cvtto64\refstepcounter{example}[\theexample]}
		\item{Delphi Parser\refstepcounter{example}[\theexample]}
	\end{enumerate}

	Дополнительный список инструментальных средств с Windows to Linux, Solaris to Linux, Linux to Linux, Other UNIX to Linux[\refstepcounter{example}[\theexample]].

	\section{Стандарты языка C}

	\textbf{Здесь привожу ключевы отличия C89/C99 от C11/C17 и надо составить "таблицу перехода" для разных стандартов, например: C89->C11, C99->C11, C89->C17, C99->C17}

	Далее я предлагаю решение о том, что по полученной таблице сравнения сформировать "правила" перехода (ниже чуть описал примеры)



	\section{Решение}

	Задачу трансляции старых исходных кодов из С89/С99 в С11/С17 можно решить следующими способами:

	\begin{itemize}
		\item{Использование регулярных выражений}
		\item{Использование абстрактного синтаксического дерева}
	\end{itemize}

	Однако, в обеих способах необходимо выделить правила перехода от старых языковых конструкций к новым.

	\subsection{Формирование правил перехода от старых конструкций языка к новым}

	Например, функция не имеет аргументов. Однако, при её вызове можно указать фактические аргументы в виде литер или переменных.

	\begin{verbatim}
		void [function_name]()
		{
			// code
		}

		// [function_name](1,2,3,4) <- compilation ok
	\end{verbatim}

	В соответствии с новыми стандартами следует писать так

	\begin{verbatim}
		void [function_name](void)
		{
			// code
		}

		// [function_name](1,2,3,4) <- compilation error
	\end{verbatim}

	В формальном виде можно было бы записать: [C89]:void *() -> [C11]:void *(void)

	ещё пару примеров


	\subsection{Прототип транскомпилятора}

	Транскомпилятор должен принимать исходный код на С89/C99 и выдавать новые исходные код на языке С11/C17. Помимо этого он должен быть кроссплатформенным и работать в операционных системах Windows, Linux, MacOS X. Также он должен представлять собой консольное приложение, принимающие соответствующие аргументы.
	
	\begin{verbatim}
		user@example:~$ CtoC -stdIn=C89 -stdOut=C11 -in=/old -out=/new
	\end{verbatim}


	\section{Заключение}

	Портирование кода, со старой версии стандарта на новый, может дать следующие преимущества:

	\begin{itemize}
		\item{Рост производительности}
		\item{При введении повсеместной практики портирования старого кода, новые версии языка могут стать более компактными, более ограниченными}
	\end{itemize}


	\section{Список литературы}

	

	\begin{enumerate}
		\item{Common Data Migration Problems [Электронный ресурс]. -- URL: \url{https://www.vxchnge.com/blog/data-migration-problems-solutions} (Дата обращения: 24.08.2021)}
		\item{Как мы перевели 10 миллионов строк кода C++ на стандарт C++14 (а потом и на C++17) [Электронный ресурс]. -- URL: \url{https://habr.com/ru/company/1c/blog/429678/} (Дата обращения: 24.08.2021)}
		\item{Миграция баз данных: зачем и почему [Электронный ресурс]. -- URL:  \url{https://lanit.ru/press/smi/migratsiya-baz-dannykh-zachem-i-pochemu/} (Дата обращения: 24.08.2021)}
		\item{HipHop for PHP [Электронный ресурс]. -- URL: \url{https://en.wikipedia.org/wiki/HipHop_for_PHP} (Дата обращения: 24.08.2021)}
		\item{Migrating C/C++ Software to Mobile Platforms in the ADM Context [Электронный ресрус]. -- URL: \url{https://digital.cic.gba.gob.ar/bitstream/handle/11746/5678/11746_5678.pdf-PDFA.pdf?sequence=1&isAllowed=y} (Дата обращения: 24.08.2021)}

		\item{Porting Assistant for .NET -- Amazon Web Services [Электронный ресурс]. -- URL: \url{https://aws.amazon.com/ru/porting-assistant-dotnet/}  (Дата обращения: 17.08.2021)}
		\item{PortAssist: Visual Analysis for Porting Large Code Bases [Электронный ресурс]. -- URL: \url{https://quelknas.myqnapcloud.com:8081/uploads/PAPERS/InfoVis11/poster.pdf} (Дата обращения: 17.08.2021)}
		\item{CodeCheck Program Overview -- URL: \url{https://www.abxsoft.com/codchk.htm}  (Дата обращения: 17.08.2021)}
		\item{Code migration tools -- IBM Documentation [Электронный ресрус]. -- URL: \url{https://www.ibm.com/docs/en/ztpf/2019?topic=tools-code-migration} (Дата обращения: 24.08.2021)}
		\item{Delphi Parser [Электронный ресрус]. -- URL: \url{https://delphiparser.com/?gclid=EAIaIQobChMIkOGr8OHB8gIVAamyCh0Lnw_ZEAAYAiAAEgKOwPD_BwE} (Дата обращения: 24.08.2021)}
		\item{Porting and Migration Tools [Электронный ресурс]. -- URL: \url{https://www.novell.com/developer/porting_and_migration_tools.html} (Дата обращения: 24.08.2021)}
		\item{}
		\item{ -- URL: \url{https://en.wikipedia.org/wiki/Source-to-source_compiler} (Дата обращения: 24.08.2021)}

		
		\item{Programming language specification [Электронный ресурс]. -- URL: \url{https://en.wikipedia.org/wiki/Programming_language_specification} }
		\item{Scientific Visualization and Computer Graphics [Электронный ресурс]. -- URL: \url{http://www.cs.rug.nl/svcg/SoftVis/Refactor} }
			
		\item{Д.В. Силаков. Методы обеспечения переносимости ПО // Статья, 2009}

		\item{-- URL: \url{https://valgrind.org/} (Дата обращения: 17.08.2021)}

		\item{}
	\end{enumerate}
	



\end{document}
